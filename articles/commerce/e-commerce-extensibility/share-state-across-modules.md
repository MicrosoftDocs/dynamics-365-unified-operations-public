---
title: Share state across modules
description: Learn how to share state across multiple modules by using data actions in Microsoft Dynamics 365 Commerce.
author: samjarawan
ms.date: 02/05/2026
ms.topic: how-to
ms.reviewer: v-griffinc
ms.search.region: Global
ms.author: asharchw
ms.search.validFrom: 2019-10-31
ms.custom: 
  - bap-template
---
# Share state across modules

[!include [banner](../includes/banner.md)]

This article describes how to share state across multiple modules by using data actions in Microsoft Dynamics 365 Commerce.

Data actions perform the important role of state management when you need to share state across multiple modules on the same page. In general, state is shared within the application state of the running Node application.

## Examples

In this example, two modules share basic interaction. One module (**sample-button**) has a button, and the other module (**sample-message**) shows a message when that button is selected.

First, you need a data action that returns an object containing the number of times the button is selected. Here's what the code looks like.

```typescript
// sample-state.ts
import { CacheType, createObservableDataAction, IAction, IActionContext, IActionInput, IAny, ICreateActionContext, IGeneric } from '@msdyn365-commerce/core';
export interface ISampleState {
    clickCount: number;
}

/**
 * SampleState - action input
 */
export class SampleStateInput implements IActionInput {
    public getCacheKey = () => `SampleState`;
    public getCacheObjectType = () => 'SampleState';
    public dataCacheType = (): CacheType => 'request';
}

/**
 * SampleState - action
 */
export async function sampleStateAction(input: SampleStateInput, ctx: IActionContext): Promise<ISampleState> {
    return { clickCount: 0 };
}

/**
 * SampleState - create new input for create action
 */
const createInput = (inputData: ICreateActionContext<IGeneric<IAny>>): IActionInput => {
    return new SampleStateInput();
};

/**
 * SampleState - create action
 */
export default createObservableDataAction<ISampleState>({
    action: <IAction<ISampleState>>sampleStateAction,
    input: createInput
});
```

In its current state, this data action has no implementation. It just creates a place to store an object in the cache. Because the two modules in this example must communicate with each other, it's helpful if they both observe this object. To give modules access to this object, make sure that the modules register the data action that you created earlier as a page load data action.

Here's the code for the **sample-button** module.

```json
// sample-button.definition.json
{
    "$type": "contentModule",
    "friendlyName": "Sample Button",
    "name": "sample-button",
    "description": "Sample Button",
    "categories": ["sample-button"],
    "tags": ["samples"],
    "module": {
        "view": "./sample-button",
        "dataActions": {
            "sampleState": {
                "path": "../../actions/sample-state/sample-state"
            }
        }
    }
}
```

Here's the code for the **sample-message** module.

```json
// sample-message.definition.json
{
    "$type": "contentModule",
    "friendlyName": "Sample Message",
    "name": "sample-message",
    "description": "Sample Message",
    "categories": ["sample-message"],
    "tags": ["samples"],
    "dataActions": {
        "sampleState": {
            "path": "../../actions/sample-state/sample-state"
        }
    }
}
```

Both modules now register to the data action. Therefore, they both observe the same object in the application state. The next step is to update the application state when the **sample-button** module has a user click event. All modules that observe the application state automatically update. Here's the code for the **sample-message** module.

```typescript
// sample-message.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
import { ISampleState } from '../../actions/sample-state/sample-state';
export interface ISampleMessageData {
    sampleState: AsyncResult<ISampleState>;
}
```

```tsx
// sample-message.tsx
import * as React from 'react';
import { ISampleMessageData } from './sample-message.data';
import { ISampleMessageProps } from './sample-message.props.autogenerated';

/**
 * SampleMessage Module used for showcasing cross-module communication
 * @extends {React.Component<ISampleMessageProps<ISampleMessageData>>}
 */
export default class SampleMessage extends React.Component<ISampleMessageProps<ISampleMessageData>> {
    constructor(props: ISampleMessageProps<ISampleMessageData>) {
        super(props);
    }
    public render(): JSX.Element {
        if(this.props.data.sampleState.result) {
            return (<h3>The Button has been clicked {this.props.data.sampleState.result.clickCount} times.</h3>);
        }
        return (<h3>Error: No Sample State Detected</h3>);
    }
}
```

The **sample-message** module is straightforward. It asks for the **ISampleState** value by using a page load data action. Then, based on the data that the module returns, it renders a simple message. Because the application state is internally powered by [MobX](https://mobx.js.org/), this module can automatically react when the data that it's observing changes. 

Finally, here's the code for the **sample-button** module that updates the application state in response to a user click event.

```typescript
// sample-button.data.ts
import { AsyncResult } from '@msdyn365-commerce/retail-proxy';
import { ISampleState } from '../../actions/sample-state/sample-state';
export interface ISampleButtonData {
    sampleState: AsyncResult<ISampleState>;
}
```

```tsx
// sample-button.tsx
import * as React from 'react';
import { ISampleButtonData } from './sample-button.data';
import { ISampleButtonProps } from './sample-button.props.autogenerated';
import { SampleStateInput } from '../../actions/sample-state/sample-state';

/**
 * SampleButton component used for showcasing cross-module communication
 * @extends {React.Component<ISampleButtonProps<ISampleButtonData>>}
 */
export default class SampleButton extends React.Component<ISampleButtonProps<ISampleButtonData>> {
    constructor(props: ISampleButtonProps<ISampleButtonData>) {
        super(props);
        this._onClick.bind(this);
    }
    public render(): JSX.Element {
        return (
            <button onClick={this._onClick}>
                Click Me!
            </button>
        );
    }

    // OnClick Handler should update application state
    private _onClick = (e: React.MouseEvent): void => {
        if (this.props.data.sampleState.result) {
            // This will directly update our application state, which should trigger all modules observing the state to update
            this.props.context.actionContext.update(new SampleStateInput(), { clickCount: this.props.data.sampleState.result.clickCount + 1 });
        }
    }
}
```

As you can see, the **onClick** handler makes a call to the **actionContext.update()**. This method lets you directly change the application state. When the state changes, MobX takes over and re-renders all the modules that observe the state, including the **sample-message** module.

## Additional resources

[Chain data actions](chain-data-actions.md)

[Batch data actions](batch-data-actions.md)

[Create an observable data action](create-observable-data-action.md)

[Data action cache settings](data-action-cache-settings.md)

[Data action overrides](data-action-overrides.md)

[Data action hooks](data-action-hooks.md)


[!INCLUDE[footer-include](../../includes/footer-banner.md)]
